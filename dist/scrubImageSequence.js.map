{"mappings":"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","sources":["<anon>","src/scrubImageSequence.js"],"sourcesContent":["(() => {\n// Scrub animation ================================================ //\nconst $c8fe6ad741db8e1e$var$sections = gsap.utils.toArray(\"[scrub-wrapper]\");\nconst $c8fe6ad741db8e1e$var$width = document.documentElement.clientWidth;\nconst $c8fe6ad741db8e1e$var$height = window.innerHeight;\nvar $c8fe6ad741db8e1e$var$mm = gsap.matchMedia();\n// Image sequence play on scroll =====================================//\nvar $c8fe6ad741db8e1e$var$allImagesCount = 0;\nvar $c8fe6ad741db8e1e$var$totalCount = 0;\n// Initialize for each section\nfunction $c8fe6ad741db8e1e$var$initSections() {\n    $c8fe6ad741db8e1e$var$sections.forEach(function(section) {\n        var prefix = section.dataset.prefix || null;\n        var suffix = section.dataset.suffix || null;\n        var frames = section.dataset.framecount || 0;\n        var canvas = section.querySelector(\"canvas\");\n        if (!canvas || !prefix || !suffix || !frames) return;\n        var device = $c8fe6ad741db8e1e$var$width >= 768 ? \"desktop\" : \"mobile\";\n        $c8fe6ad741db8e1e$var$allImagesCount += Number(frames);\n        $c8fe6ad741db8e1e$var$totalCount += Number(frames);\n        $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device);\n    });\n}\n$c8fe6ad741db8e1e$var$mm.add(\"(min-width: 768px)\", ()=>{\n    // desktop\n    $c8fe6ad741db8e1e$var$initSections();\n});\n$c8fe6ad741db8e1e$var$mm.add(\"(max-width: 767px)\", ()=>{\n    // mobile\n    $c8fe6ad741db8e1e$var$initSections();\n});\n//var $loadingNum = $('.loading-number');\n//var $loadingProgress = $('.loading-number-progress');\nfunction $c8fe6ad741db8e1e$var$updateImageSequenceCount(file) {\n    $c8fe6ad741db8e1e$var$allImagesCount--;\n    var updatedPercent = 100 - Math.round($c8fe6ad741db8e1e$var$allImagesCount * 100 / $c8fe6ad741db8e1e$var$totalCount);\n    //$loadingNum.text(updatedPercent + '%');\n    //$loadingProgress.css('transform', 'translate3d(' + updatedPercent +'%, 0,0)');\n    // console.log(updatedPercent);\n    if ($c8fe6ad741db8e1e$var$allImagesCount === 0) //$('.loading-disable').click();\n    setTimeout(function() {\n        lenis.resize();\n    }, 500);\n}\n// Initialize animation on canvas for each section. This loads\n// the image sequence and make sure to load the right image based\n// on scroll position.\nfunction $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device) {\n    var context = canvas.getContext(\"2d\");\n    canvas.width = $c8fe6ad741db8e1e$var$width;\n    canvas.height = $c8fe6ad741db8e1e$var$height;\n    var frameCount = frames;\n    var currentFrame = function(index) {\n        return `${prefix}${device}/${(index + 1).toString().padStart(3, \"0\")}${suffix}`;\n    };\n    var images = [];\n    // loads all images for this sequence and checks if we loaded everything\n    // for this page.\n    for(var i = 0; i < frameCount; i++){\n        var img = new Image();\n        var imgSrc = currentFrame(i);\n        img.onload = function() {\n            $c8fe6ad741db8e1e$var$updateImageSequenceCount(imgSrc);\n            if ($c8fe6ad741db8e1e$var$allImagesCount === 0) $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas);\n        };\n        img.onerror = function() {\n            $c8fe6ad741db8e1e$var$updateImageSequenceCount(imgSrc);\n        };\n        img.src = imgSrc;\n        images.push(img);\n    }\n}\nfunction $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas) {\n    var sequence = {\n        frame: 0\n    };\n    var blocks = section.querySelectorAll(\"[frames-play]\");\n    blocks.forEach(function(block) {\n        var start = Number(block.dataset.start), end = Number(block.dataset.end), posStart = block.dataset.startPos || \"top top\", posEnd = block.dataset.endPos || \"bottom bottom\";\n        var blockSequence = {\n            frame: 0\n        };\n        // Initializes timeline for scroll animation.\n        gsap.timeline({\n            onUpdate: function() {\n                $c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas);\n            },\n            scrollTrigger: {\n                trigger: block,\n                pin: false,\n                scrub: 1,\n                start: posStart,\n                end: posEnd,\n                markers: false\n            }\n        }).fromTo(blockSequence, {\n            frame: start - 1\n        }, {\n            frame: end - 1,\n            snap: \"frame\",\n            ease: \"none\",\n            duration: 1\n        }, 0);\n    });\n    $c8fe6ad741db8e1e$var$render(images, sequence, context, canvas);\n    window.addEventListener(\"resize\", function() {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = window.innerHeight;\n        $c8fe6ad741db8e1e$var$render(images, sequence, context, canvas);\n    });\n}\n// Makes sure that the canvas is responsive, and updates the current\n// painted image depending on the scroll position.\nfunction $c8fe6ad741db8e1e$var$render(images, sequence, context, canvas) {\n    var img = images[sequence.frame];\n    // console.log(sequence.frame);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    var loadedImageWidth = img.width;\n    var loadedImageHeight = img.height;\n    // get the scale\n    // it is the min of the 2 ratios\n    var scaleFactor = Math.max(canvas.width / img.width, canvas.height / img.height);\n    // Finding the new width and height based on the scale factor\n    var newWidth = img.width * scaleFactor;\n    var newHeight = img.height * scaleFactor;\n    //console.log(img.width, img.height, scaleFactor, newWidth, newHeight);\n    // get the top left position of the image\n    // in order to center the image within the canvas\n    var x = canvas.width / 2 - newWidth / 2;\n    var y = canvas.height / 2 - newHeight / 2;\n    // When drawing the image, we have to scale down the image\n    // width and height in order to fit within the canvas\n    context.drawImage(img, x, y, newWidth, newHeight);\n}\n\n})();\n//# sourceMappingURL=scrubImageSequence.js.map\n","// Scrub animation ================================================ //\nconst sections = gsap.utils.toArray(\"[scrub-wrapper]\");\nconst width = document.documentElement.clientWidth;\nconst height = window.innerHeight;\n\nvar mm = gsap.matchMedia();\n\n// Image sequence play on scroll =====================================//\n\nvar allImagesCount = 0;\nvar totalCount = 0;\n\n// Initialize for each section\nfunction initSections() {\n  sections.forEach(function (section) {\n    var prefix = section.dataset.prefix || null;\n    var suffix = section.dataset.suffix || null;\n    var frames = section.dataset.framecount || 0;\n    var canvas = section.querySelector(\"canvas\");\n    if (!canvas || !prefix || !suffix || !frames) {\n      return;\n    }\n\n    var device = width >= 768 ? \"desktop\" : \"mobile\";\n\n    allImagesCount += Number(frames);\n    totalCount += Number(frames);\n    initCanvas(section, canvas, prefix, suffix, frames, device);\n  });\n}\n\nmm.add(\"(min-width: 768px)\", () => {\n  // desktop\n  initSections();\n});\n\nmm.add(\"(max-width: 767px)\", () => {\n  // mobile\n  initSections();\n});\n\n//var $loadingNum = $('.loading-number');\n//var $loadingProgress = $('.loading-number-progress');\nfunction updateImageSequenceCount(file) {\n  allImagesCount--;\n\n  var updatedPercent = 100 - Math.round((allImagesCount * 100) / totalCount);\n  //$loadingNum.text(updatedPercent + '%');\n  //$loadingProgress.css('transform', 'translate3d(' + updatedPercent +'%, 0,0)');\n  // console.log(updatedPercent);\n\n  if (allImagesCount === 0) {\n    //$('.loading-disable').click();\n    setTimeout(function () {\n      lenis.resize();\n    }, 500);\n  }\n}\n\n// Initialize animation on canvas for each section. This loads\n// the image sequence and make sure to load the right image based\n// on scroll position.\nfunction initCanvas(section, canvas, prefix, suffix, frames, device) {\n  var context = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n\n  var frameCount = frames;\n  var currentFrame = function (index) {\n    return `${prefix}${device}/${(index + 1)\n      .toString()\n      .padStart(3, \"0\")}${suffix}`;\n  };\n\n  var images = [];\n  // loads all images for this sequence and checks if we loaded everything\n  // for this page.\n  for (var i = 0; i < frameCount; i++) {\n    var img = new Image();\n    var imgSrc = currentFrame(i);\n\n    img.onload = function () {\n      updateImageSequenceCount(imgSrc);\n      if (allImagesCount === 0) {\n        initCanvasAnimations(section, images, context, canvas);\n      }\n    };\n    img.onerror = function () {\n      updateImageSequenceCount(imgSrc);\n    };\n    img.src = imgSrc;\n    images.push(img);\n  }\n}\n\nfunction initCanvasAnimations(section, images, context, canvas) {\n  var sequence = {\n    frame: 0,\n  };\n\n  var blocks = section.querySelectorAll(\"[frames-play]\");\n\n  blocks.forEach(function (block) {\n    var start = Number(block.dataset.start),\n      end = Number(block.dataset.end),\n      posStart = block.dataset.startPos || \"top top\",\n      posEnd = block.dataset.endPos || \"bottom bottom\";\n\n    var blockSequence = {\n      frame: 0,\n    };\n\n    // Initializes timeline for scroll animation.\n    gsap\n      .timeline({\n        onUpdate: function () {\n          render(images, blockSequence, context, canvas);\n        },\n        scrollTrigger: {\n          trigger: block,\n          pin: false,\n          scrub: 1,\n          start: posStart,\n          end: posEnd,\n          markers: false,\n        },\n      })\n      .fromTo(\n        blockSequence,\n        {\n          frame: start - 1,\n        },\n        {\n          frame: end - 1,\n          snap: \"frame\",\n          ease: \"none\",\n          duration: 1,\n        },\n        0\n      );\n  });\n\n  render(images, sequence, context, canvas);\n\n  window.addEventListener(\"resize\", function () {\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = window.innerHeight;\n    render(images, sequence, context, canvas);\n  });\n}\n\n// Makes sure that the canvas is responsive, and updates the current\n// painted image depending on the scroll position.\nfunction render(images, sequence, context, canvas) {\n  var img = images[sequence.frame];\n  // console.log(sequence.frame);\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  var loadedImageWidth = img.width;\n  var loadedImageHeight = img.height;\n\n  // get the scale\n  // it is the min of the 2 ratios\n  var scaleFactor = Math.max(\n    canvas.width / img.width,\n    canvas.height / img.height\n  );\n\n  // Finding the new width and height based on the scale factor\n  var newWidth = img.width * scaleFactor;\n  var newHeight = img.height * scaleFactor;\n\n  //console.log(img.width, img.height, scaleFactor, newWidth, newHeight);\n\n  // get the top left position of the image\n  // in order to center the image within the canvas\n  var x = canvas.width / 2 - newWidth / 2;\n  var y = canvas.height / 2 - newHeight / 2;\n\n  // When drawing the image, we have to scale down the image\n  // width and height in order to fit within the canvas\n  context.drawImage(img, x, y, newWidth, newHeight);\n}\n"],"names":["$c8fe6ad741db8e1e$var$sections","gsap","utils","toArray","$c8fe6ad741db8e1e$var$width","document","documentElement","clientWidth","$c8fe6ad741db8e1e$var$height","window","innerHeight","$c8fe6ad741db8e1e$var$mm","matchMedia","$c8fe6ad741db8e1e$var$allImagesCount","$c8fe6ad741db8e1e$var$totalCount","$c8fe6ad741db8e1e$var$initSections","forEach","section","prefix","dataset","suffix","frames","framecount","canvas","querySelector","Number","$c8fe6ad741db8e1e$var$initCanvas","device","context","getContext","width","height","images","i","index","img","Image","imgSrc","toString","padStart","onload","$c8fe6ad741db8e1e$var$updateImageSequenceCount","$c8fe6ad741db8e1e$var$initCanvasAnimations","sequence","frame","blocks","querySelectorAll","block","start","end","posStart","startPos","posEnd","endPos","blockSequence","timeline","onUpdate","$c8fe6ad741db8e1e$var$render","scrollTrigger","trigger","pin","scrub","markers","fromTo","snap","ease","duration","addEventListener","onerror","src","push","file","setTimeout","lenis","resize","clearRect","scaleFactor","Math","max","newWidth","newHeight","x","y","drawImage","add"],"version":3,"file":"scrubImageSequence.js.map"}