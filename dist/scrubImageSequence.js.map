{"mappings":"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","sources":["<anon>","src/scrubImageSequence.js"],"sourcesContent":["(() => {\n// Scrub animation ================================================ //\nconst $c8fe6ad741db8e1e$var$sections = gsap.utils.toArray(\"[scrub-wrapper]\");\nconst $c8fe6ad741db8e1e$var$width = document.documentElement.clientWidth;\nconst $c8fe6ad741db8e1e$var$height = window.innerHeight;\nvar $c8fe6ad741db8e1e$var$mm = gsap.matchMedia();\n// Image sequence progressive loading system ======================= //\n// Initialize for each section\nfunction $c8fe6ad741db8e1e$var$initSections() {\n    $c8fe6ad741db8e1e$var$sections.forEach(function(section) {\n        var prefix = section.dataset.prefix || null;\n        var suffix = section.dataset.suffix || null;\n        var frames = Number(section.dataset.framecount || 0);\n        var canvas = section.querySelector(\"canvas\");\n        if (!canvas || !prefix || !suffix || !frames) return;\n        var device = $c8fe6ad741db8e1e$var$width >= 768 ? \"desktop\" : \"mobile\";\n        $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device);\n    });\n}\n$c8fe6ad741db8e1e$var$mm.add(\"(min-width: 768px)\", ()=>$c8fe6ad741db8e1e$var$initSections());\n$c8fe6ad741db8e1e$var$mm.add(\"(max-width: 767px)\", ()=>$c8fe6ad741db8e1e$var$initSections());\n// Initialize animation on canvas for each section. Progressive load.\nfunction $c8fe6ad741db8e1e$var$initCanvas(section, canvas, prefix, suffix, frames, device) {\n    const context = canvas.getContext(\"2d\");\n    canvas.width = $c8fe6ad741db8e1e$var$width;\n    canvas.height = $c8fe6ad741db8e1e$var$height;\n    const frameCount = frames;\n    const images = new Array(frameCount).fill(null);\n    // Build file source\n    const getSrc = (i)=>`${prefix}${device}/${(i + 1).toString().padStart(3, \"0\")}${suffix}`;\n    // Progressive quad-pass loader (pass 0 → 1 → 2 → 3)\n    function loadPass(pass = 0) {\n        let loadedInPass = 0;\n        for(let i = pass; i < frameCount; i += 4){\n            if (images[i]) continue; // Already loaded\n            const img = new Image();\n            img.src = getSrc(i);\n            img.onload = ()=>{\n                images[i] = img;\n                loadedInPass++;\n                // First frame of first pass initializes animation immediately\n                if (pass === 0 && loadedInPass === 1) $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas);\n                // Check if all frames of this pass are loaded\n                const allLoadedInPass = images.map((img, idx)=>idx % 4 === pass ? !!img : true).every(Boolean);\n                if (allLoadedInPass && pass < 3) loadPass(pass + 1); // Load next pass\n            };\n            img.onerror = ()=>{\n                images[i] = \"error\";\n            };\n        }\n    }\n    // Start progressive loading\n    loadPass(0);\n}\n// Create ScrollTrigger animations once first frame is ready\nfunction $c8fe6ad741db8e1e$var$initCanvasAnimations(section, images, context, canvas) {\n    var blocks = section.querySelectorAll(\"[frames-play]\");\n    blocks.forEach(function(block) {\n        var start = Number(block.dataset.start);\n        var end = Number(block.dataset.end);\n        var posStart = block.dataset.startPos || \"top top\";\n        var posEnd = block.dataset.endPos || \"bottom bottom\";\n        var blockSequence = {\n            frame: start - 1\n        };\n        gsap.timeline({\n            onUpdate: ()=>$c8fe6ad741db8e1e$var$render(images, blockSequence, context, canvas),\n            scrollTrigger: {\n                trigger: block,\n                pin: false,\n                scrub: 1,\n                start: posStart,\n                end: posEnd,\n                markers: false\n            }\n        }).fromTo(blockSequence, {\n            frame: start - 1\n        }, {\n            frame: end - 1,\n            snap: \"frame\",\n            ease: \"none\",\n            duration: 1\n        }, 0);\n    });\n    // First render\n    $c8fe6ad741db8e1e$var$render(images, {\n        frame: 0\n    }, context, canvas);\n    // Responsive resize\n    window.addEventListener(\"resize\", function() {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = window.innerHeight;\n        $c8fe6ad741db8e1e$var$render(images, {\n            frame: 0\n        }, context, canvas);\n    });\n}\n// Render function with fallback for not-yet-loaded frames\nfunction $c8fe6ad741db8e1e$var$render(images, sequence, context, canvas) {\n    let frameIndex = sequence.frame;\n    let img = images[frameIndex];\n    // Look backward for nearest loaded frame\n    if (!img || img === \"error\") {\n        for(let i = frameIndex - 1; i >= 0; i--)if (images[i] && images[i] !== \"error\") {\n            img = images[i];\n            break;\n        }\n    }\n    // Look forward if still missing\n    if (!img || img === \"error\") {\n        for(let i = frameIndex + 1; i < images.length; i++)if (images[i] && images[i] !== \"error\") {\n            img = images[i];\n            break;\n        }\n    }\n    // If no valid images yet, skip drawing\n    if (!img || img === \"error\") return;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // Scale image to cover canvas\n    const scaleFactor = Math.max(canvas.width / img.width, canvas.height / img.height);\n    const newWidth = img.width * scaleFactor;\n    const newHeight = img.height * scaleFactor;\n    const x = (canvas.width - newWidth) / 2;\n    const y = (canvas.height - newHeight) / 2;\n    context.drawImage(img, x, y, newWidth, newHeight);\n}\n\n})();\n//# sourceMappingURL=scrubImageSequence.js.map\n","// Scrub animation ================================================ //\nconst sections = gsap.utils.toArray(\"[scrub-wrapper]\");\nconst width = document.documentElement.clientWidth;\nconst height = window.innerHeight;\n\nvar mm = gsap.matchMedia();\n\n// Image sequence progressive loading system ======================= //\n\n// Initialize for each section\nfunction initSections() {\n  sections.forEach(function (section) {\n    var prefix = section.dataset.prefix || null;\n    var suffix = section.dataset.suffix || null;\n    var frames = Number(section.dataset.framecount || 0);\n    var canvas = section.querySelector(\"canvas\");\n\n    if (!canvas || !prefix || !suffix || !frames) return;\n\n    var device = width >= 768 ? \"desktop\" : \"mobile\";\n\n    initCanvas(section, canvas, prefix, suffix, frames, device);\n  });\n}\n\nmm.add(\"(min-width: 768px)\", () => initSections());\nmm.add(\"(max-width: 767px)\", () => initSections());\n\n// Initialize animation on canvas for each section. Progressive load.\nfunction initCanvas(section, canvas, prefix, suffix, frames, device) {\n  const context = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n\n  const frameCount = frames;\n  const images = new Array(frameCount).fill(null);\n\n  // Build file source\n  const getSrc = (i) =>\n    `${prefix}${device}/${(i + 1).toString().padStart(3, \"0\")}${suffix}`;\n\n  // Progressive quad-pass loader (pass 0 → 1 → 2 → 3)\n  function loadPass(pass = 0) {\n    let loadedInPass = 0;\n\n    for (let i = pass; i < frameCount; i += 4) {\n      if (images[i]) continue; // Already loaded\n\n      const img = new Image();\n      img.src = getSrc(i);\n\n      img.onload = () => {\n        images[i] = img;\n        loadedInPass++;\n\n        // First frame of first pass initializes animation immediately\n        if (pass === 0 && loadedInPass === 1) {\n          initCanvasAnimations(section, images, context, canvas);\n        }\n\n        // Check if all frames of this pass are loaded\n        const allLoadedInPass = images\n          .map((img, idx) => (idx % 4 === pass ? !!img : true))\n          .every(Boolean);\n\n        if (allLoadedInPass && pass < 3) {\n          loadPass(pass + 1); // Load next pass\n        }\n      };\n\n      img.onerror = () => {\n        images[i] = \"error\";\n      };\n    }\n  }\n\n  // Start progressive loading\n  loadPass(0);\n}\n\n// Create ScrollTrigger animations once first frame is ready\nfunction initCanvasAnimations(section, images, context, canvas) {\n  var blocks = section.querySelectorAll(\"[frames-play]\");\n\n  blocks.forEach(function (block) {\n    var start = Number(block.dataset.start);\n    var end = Number(block.dataset.end);\n    var posStart = block.dataset.startPos || \"top top\";\n    var posEnd = block.dataset.endPos || \"bottom bottom\";\n\n    var blockSequence = { frame: start - 1 };\n\n    gsap\n      .timeline({\n        onUpdate: () => render(images, blockSequence, context, canvas),\n        scrollTrigger: {\n          trigger: block,\n          pin: false,\n          scrub: 1,\n          start: posStart,\n          end: posEnd,\n          markers: false,\n        },\n      })\n      .fromTo(\n        blockSequence,\n        { frame: start - 1 },\n        {\n          frame: end - 1,\n          snap: \"frame\",\n          ease: \"none\",\n          duration: 1,\n        },\n        0\n      );\n  });\n\n  // First render\n  render(images, { frame: 0 }, context, canvas);\n\n  // Responsive resize\n  window.addEventListener(\"resize\", function () {\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = window.innerHeight;\n    render(images, { frame: 0 }, context, canvas);\n  });\n}\n\n// Render function with fallback for not-yet-loaded frames\nfunction render(images, sequence, context, canvas) {\n  let frameIndex = sequence.frame;\n  let img = images[frameIndex];\n\n  // Look backward for nearest loaded frame\n  if (!img || img === \"error\") {\n    for (let i = frameIndex - 1; i >= 0; i--) {\n      if (images[i] && images[i] !== \"error\") {\n        img = images[i];\n        break;\n      }\n    }\n  }\n\n  // Look forward if still missing\n  if (!img || img === \"error\") {\n    for (let i = frameIndex + 1; i < images.length; i++) {\n      if (images[i] && images[i] !== \"error\") {\n        img = images[i];\n        break;\n      }\n    }\n  }\n\n  // If no valid images yet, skip drawing\n  if (!img || img === \"error\") return;\n\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Scale image to cover canvas\n  const scaleFactor = Math.max(\n    canvas.width / img.width,\n    canvas.height / img.height\n  );\n\n  const newWidth = img.width * scaleFactor;\n  const newHeight = img.height * scaleFactor;\n\n  const x = (canvas.width - newWidth) / 2;\n  const y = (canvas.height - newHeight) / 2;\n\n  context.drawImage(img, x, y, newWidth, newHeight);\n}\n"],"names":["$c8fe6ad741db8e1e$var$sections","gsap","utils","toArray","$c8fe6ad741db8e1e$var$width","document","documentElement","clientWidth","$c8fe6ad741db8e1e$var$height","window","innerHeight","$c8fe6ad741db8e1e$var$mm","matchMedia","$c8fe6ad741db8e1e$var$initSections","forEach","section","prefix","dataset","suffix","frames","Number","framecount","canvas","querySelector","$c8fe6ad741db8e1e$var$initCanvas","device","context","getContext","width","height","images","Array","fill","getSrc","i","toString","padStart","loadPass","pass","loadedInPass","img","Image","src","onload","$c8fe6ad741db8e1e$var$initCanvasAnimations","blocks","querySelectorAll","block","start","end","posStart","startPos","posEnd","endPos","blockSequence","frame","timeline","onUpdate","$c8fe6ad741db8e1e$var$render","scrollTrigger","trigger","pin","scrub","markers","fromTo","snap","ease","duration","addEventListener","map","idx","every","Boolean","onerror","sequence","frameIndex","length","clearRect","scaleFactor","Math","max","newWidth","newHeight","x","y","drawImage","add"],"version":3,"file":"scrubImageSequence.js.map"}